"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Hashing = exports.Oberon = exports.LdProofs = exports.DIDComm = exports.DIDKey = void 0;
const native = __importStar(require("@trinsic/okapi-node"));
const proto = __importStar(require("@trinsic/okapi-proto"));
__exportStar(require("@trinsic/okapi-proto"), exports);
class DIDKey {
    static generate(request) {
        return Promise.resolve(proto.GenerateKeyResponse.deserializeBinary(native.didkey_generate(request.serializeBinary())));
    }
    static resolve(request) {
        return Promise.resolve(proto.ResolveResponse.deserializeBinary(native.didkey_resolve(request.serializeBinary())));
    }
}
exports.DIDKey = DIDKey;
class DIDComm {
    static pack(request) {
        return Promise.resolve(proto.PackResponse.deserializeBinary(native.didcomm_pack(request.serializeBinary())));
    }
    static unpack(request) {
        return Promise.resolve(proto.UnpackResponse.deserializeBinary(native.didcomm_unpack(request.serializeBinary())));
    }
    static sign(request) {
        return Promise.resolve(proto.SignResponse.deserializeBinary(native.didcomm_sign(request.serializeBinary())));
    }
    static verify(request) {
        return Promise.resolve(proto.VerifyResponse.deserializeBinary(native.didcomm_verify(request.serializeBinary())));
    }
}
exports.DIDComm = DIDComm;
class LdProofs {
    static generate(request) {
        return Promise.resolve(proto.CreateProofResponse.deserializeBinary(native.ldproofs_create_proof(request.serializeBinary())));
    }
    static convert(request) {
        return Promise.resolve(proto.VerifyProofResponse.deserializeBinary(native.ldproofs_verify_proof(request.serializeBinary())));
    }
}
exports.LdProofs = LdProofs;
class Oberon {
    static createKey(request) {
        return Promise.resolve(proto.CreateOberonKeyResponse.deserializeBinary(native.oberon_create_key(request.serializeBinary())));
    }
    static createToken(request) {
        return Promise.resolve(proto.CreateOberonTokenResponse.deserializeBinary(native.oberon_create_token(request.serializeBinary())));
    }
    static createProof(request) {
        return Promise.resolve(proto.CreateOberonProofResponse.deserializeBinary(native.oberon_create_proof(request.serializeBinary())));
    }
    static verifyProof(request) {
        return Promise.resolve(proto.VerifyOberonProofResponse.deserializeBinary(native.oberon_verify_proof(request.serializeBinary())));
    }
    static blindToken(request) {
        return Promise.resolve(proto.BlindOberonTokenResponse.deserializeBinary(native.oberon_blind_token(request.serializeBinary())));
    }
    static unblindToken(request) {
        return Promise.resolve(proto.UnBlindOberonTokenResponse.deserializeBinary(native.oberon_unblind_token(request.serializeBinary())));
    }
}
exports.Oberon = Oberon;
class Hashing {
    static blake3Hash(request) {
        return Promise.resolve(proto.Blake3HashResponse.deserializeBinary(native.blake3_hash(request.serializeBinary())));
    }
    static blake3KeyedHash(request) {
        return Promise.resolve(proto.Blake3KeyedHashResponse.deserializeBinary(native.blake3_keyed_hash(request.serializeBinary())));
    }
    static blake3DeriveKey(request) {
        return Promise.resolve(proto.Blake3DeriveKeyResponse.deserializeBinary(native.blake3_derive_key(request.serializeBinary())));
    }
    static sha256Hash(request) {
        return Promise.resolve(proto.SHA256HashResponse.deserializeBinary(native.sha256_hash(request.serializeBinary())));
    }
}
exports.Hashing = Hashing;
//# sourceMappingURL=index.js.map