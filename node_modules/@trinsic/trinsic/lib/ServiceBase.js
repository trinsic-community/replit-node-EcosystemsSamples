"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const grpc_js_1 = require("@grpc/grpc-js");
const proto_1 = require("./proto/");
const base64url_1 = __importDefault(require("base64url"));
const okapi_1 = require("@trinsic/okapi");
class ServiceBase {
    options;
    channel;
    channelCredentials;
    address;
    constructor(options = new proto_1.ServiceOptions()) {
        options.setServerEndpoint(options.getServerEndpoint() || "prod.trinsic.cloud")
            .setServerPort(options.getServerPort() || 443)
            .setServerUseTls(options.getServerPort() == 443 ? true : options.getServerUseTls())
            .setDefaultEcosystem(options.getDefaultEcosystem() || "default");
        this.options = options;
        this.address = `${this.options.getServerEndpoint()}:${this.options.getServerPort()}`;
        this.channelCredentials = this.options.getServerUseTls()
            ? grpc_js_1.ChannelCredentials.createSsl()
            : grpc_js_1.ChannelCredentials.createInsecure();
    }
    async getMetadata(request) {
        if (!this.options.getAuthToken()) {
            throw new Error("auth token must be set");
        }
        var profile = proto_1.AccountProfile.deserializeBinary(Buffer.from(this.options.getAuthToken(), 'base64url'));
        if (profile.getProtection()?.getEnabled()) {
            throw new Error("profile is protected; you must use security code to remove the protection first");
        }
        let requestData = request.serializeBinary();
        let requestHash = Buffer.from('');
        if (requestData.length > 0) {
            let hashResponse = await okapi_1.Hashing.blake3Hash(new okapi_1.Blake3HashRequest()
                .setData(requestData));
            requestHash = Buffer.from(hashResponse.getDigest_asU8());
        }
        const timestamp = Date.now();
        let nonce = new proto_1.Nonce().setTimestamp(timestamp).setRequestHash(requestHash);
        let proof = await okapi_1.Oberon.createProof(new okapi_1.CreateOberonProofRequest()
            .setNonce(nonce.serializeBinary())
            .setData(profile.getAuthData())
            .setToken(profile.getAuthToken()));
        const metadata = new grpc_js_1.Metadata();
        metadata.add("authorization", `Oberon ` +
            `ver=1,` +
            `proof=${base64url_1.default.encode(Buffer.from(proof.getProof_asU8()))},` +
            `data=${base64url_1.default.encode(Buffer.from(profile.getAuthData_asU8()))},` +
            `nonce=${base64url_1.default.encode(Buffer.from(nonce.serializeBinary()))}`);
        return metadata;
    }
}
exports.default = ServiceBase;
//# sourceMappingURL=ServiceBase.js.map