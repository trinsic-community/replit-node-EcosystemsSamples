"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.AccountService = void 0;
const ServiceBase_1 = __importDefault(require("./ServiceBase"));
const proto_1 = require("./proto");
const okapi_1 = require("@trinsic/okapi");
class AccountService extends ServiceBase_1.default {
    client;
    constructor(options) {
        super(options);
        this.client = new proto_1.AccountClient(this.address, this.channelCredentials);
    }
    signIn(request) {
        request.setEcosystemId(request.getEcosystemId() || this.options.getDefaultEcosystem());
        return new Promise((resolve, reject) => {
            this.client.signIn(request, (error, response) => {
                if (error || response.getStatus() != proto_1.ResponseStatus.SUCCESS) {
                    reject(error);
                }
                else {
                    var authToken = Buffer
                        .from(response.getProfile().serializeBinary())
                        .toString('base64');
                    // set the auth token as active for the current service instance
                    this.options.setAuthToken(authToken);
                    resolve(authToken);
                }
            });
        });
    }
    info() {
        const request = new proto_1.InfoRequest();
        return new Promise(async (resolve, reject) => {
            this.client.info(request, await this.getMetadata(request), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            });
        });
    }
    async protect(profile, securityCode) {
        const cloned = profile.clone();
        const request = new okapi_1.BlindOberonTokenRequest().setToken(cloned.getAuthToken()).setBlindingList([securityCode]);
        const result = await okapi_1.Oberon.blindToken(request);
        return cloned.setAuthToken(result.getToken()).setProtection(new proto_1.TokenProtection().setEnabled(true).setMethod(proto_1.ConfirmationMethod.OTHER));
    }
    async unprotect(profile, securityCode) {
        const cloned = profile.clone();
        const request = new okapi_1.UnBlindOberonTokenRequest().setToken(cloned.getAuthToken()).setBlindingList([securityCode]);
        const result = await okapi_1.Oberon.unblindToken(request);
        return cloned.setAuthToken(result.getToken()).setProtection(new proto_1.TokenProtection().setEnabled(false).setMethod(proto_1.ConfirmationMethod.NONE));
    }
    listDevices(request) {
        return new Promise(async (resolve, reject) => {
            this.client.listDevices(request, await this.getMetadata(request), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            });
        });
    }
    revokeDevice(request) {
        return new Promise(async (resolve, reject) => {
            this.client.revokeDevice(request, await this.getMetadata(request), (error, response) => {
                if (error) {
                    reject(error);
                }
                else {
                    resolve(response);
                }
            });
        });
    }
}
exports.AccountService = AccountService;
//# sourceMappingURL=AccountService.js.map